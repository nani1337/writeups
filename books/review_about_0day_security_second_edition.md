# 读《0day安全：软件漏洞分析技术》有感

* 目录
  * [0x00_写在前面](#0x00_写在前面)
  * [0x01_漏洞](#0x01_漏洞)
  * [0x02_二进制漏洞攻防的进化史](0x02_二进制漏洞攻防的进化史)
  * [0x03_漏洞挖掘](0x03_漏洞挖掘)

## 0x00_写在前面

《0day安全》是至今国内漏洞领域难得的宝典，13年就买来了放着，到今年才从头到尾仔细看了一遍。以前有一种误区，总感觉这本书内容太旧，于是就喜欢找一些最新的漏洞利用文章来看，虽然大致意思能懂，但真正做起来实验，却是处处碰壁。知识虽旧，历久弥坚。没有这本书的知识作为基础，是很难有更深的造诣的。很多童鞋都是因为没有建立起坚实的地基，导致很难在漏洞领域走下去。

非好奇心不胜也，乃道之不传也久矣。

本书主要从攻防两个角度介绍了Windows平台下软件漏洞的分析、利用和挖掘等方面的知识。这篇读后感，主要写写二进制漏洞攻防的进化史，这个题目给自己规定很久了，写在终于付诸纸面。

## 0x01_漏洞

无论是栈溢出、堆溢出，还是SQL注入、反序列化漏洞等等，它们在利用上都有一个共同点：

`能够将用户可控的输入通过漏洞转变为超出程序原本规定范围的越界行为.`

一款视频播放器软件，你可能只希望通过它观看电影，但当你打开一个被恶意构造的avi文件时，你的电脑竟然因为这个文件被植入了木马，你电脑中的资料、摄像头，都受到了威胁；用户用浏览器打开了一个查询商品报价的页面，但恶意用户通过修改提交的URL，不仅查询了商品报价，还从数据库中读取了本不应该看到的商品销售记录。这些都是播放器或网页本不应该提供的`越界行为`。

对漏洞领域的研究，主要涉及漏洞分析、漏洞利用和漏洞挖掘三个方面。

漏洞利用才是实施有效攻击的最核心技术，这一点，笔者也十分认同，而完成漏洞利用的前提，就是对漏洞原理的分析。漏洞分析，从本质上来说，就是要确定`漏洞产生的根本原因（没有判断字符串的输入长度）`、`触发漏洞的输入变量（字符串）`和`漏洞造成的最直接影响（比如最多溢出栈内存的多少个字节）`三点。

触发漏洞的输入变量，即POC。最常见的方式就是`根据公开的POC代码，分析软件逻辑，找到漏洞产生的根本原因，预估漏洞可以造成什么影响`。还有一种情况就是没有人公开POC，但程序已经打过补丁，此时就要分析者通过`补丁对比`，根据程序补丁前后的不同点，分析软件逻辑，找到漏洞点，逆推得到POC代码，然后再预估漏洞造成的影响。可以看出，`补丁对比`需要从一穷二白开始找到对漏洞分析的三点，不仅需要分析者熟知漏洞分析技巧，还要具备很强的逆向功底，因此，这也是漏洞分析领域技术含量最高的硬骨头。

产生漏洞最直观的解释就是，特殊的输入变量导致软件执行了特殊的程序逻辑。对漏洞的挖掘也因此分为了两类：学术界热衷于使用`静态分析`找到特殊的程序逻辑，工程界普遍采用`fuzzing`构造特殊的输入变量，目前结合两者，又出现了`符号执行`，利用符号模拟输入变量，执行不同的程序路径，进而一个程序路径对应一个方程，要想知道特定程序分支的输入变量，求解方程即可。

## 0x02_二进制漏洞攻防的进化史

一个二进制文件，被系统执行起来，需要映射到
现代计算机都遵循冯诺依曼结构，而冯诺依曼结构的精髓在于：

> 处理器按照顺序执行指令和操作数据，而无论指令还是数据，它们的本质并没有区别，都是一串二进制数字的序列。

正因为用户输入的数据和开发者编写的指令在执行过程中全部被映射到一块4GB的虚拟内存当中（32位系统），如果存在漏洞的某些指令，将用户输入的数据，不小心覆盖掉了某些指令，或者覆盖掉了某些其它数据，而这些指令或数据被执行时，实际上是执行了用户输入的数据，这样就造成了漏洞利用。

缓冲区溢出是最常见的二进制漏洞，其原理是：

> 在大缓冲区的数据向小缓冲区复制的过程中，由于没有注意小缓冲区的边界，`撑爆`较小的缓冲区，从而冲掉了和小缓冲区相邻内存的其它数据而引起的内存问题.

进程在虚拟内存中，会被映射位代码区、数据区、栈区、堆区四部分。





