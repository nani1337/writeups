# 读《0day安全：软件漏洞分析技术》有感

* 目录
  * [0x00_写在前面](#0x00_写在前面)
  * [0x01_漏洞](#0x01_漏洞)
  * [0x02_二进制漏洞攻防的进化史](#0x02_二进制漏洞攻防的进化史)
  * [0x03_漏洞挖掘](0x03_漏洞挖掘)

## 0x00_写在前面

《0day安全》是至今国内漏洞领域难得的宝典，13年就买来了放着，到今年才从头到尾仔细看了一遍。以前有一种误区，总感觉这本书内容太旧，于是就喜欢找一些最新的漏洞利用文章来看，虽然大致意思能懂，但真正做起来实验，却是处处碰壁。知识虽旧，历久弥坚。没有这本书的知识作为基础，是很难有更深的造诣的。很多童鞋都是因为没有建立起坚实的地基，导致很难在漏洞领域走下去。

非好奇心不胜也，乃道之不传也久矣。

本书主要从攻防两个角度介绍了Windows平台下软件漏洞的分析、利用和挖掘等方面的知识。这篇读后感，主要写写二进制漏洞攻防的进化史，这个题目给自己规定很久了，写在终于付诸纸面。

## 0x01_漏洞

无论是栈溢出、堆溢出，还是SQL注入、反序列化漏洞等等，它们在利用上都有一个共同点：

`能够将用户可控的输入通过漏洞转变为超出程序原本规定范围的越界行为.`

一款视频播放器软件，你可能只希望通过它观看电影，但当你打开一个被恶意构造的avi文件时，你的电脑竟然因为这个文件被植入了木马，你电脑中的资料、摄像头，都受到了威胁；用户用浏览器打开了一个查询商品报价的页面，但恶意用户通过修改提交的URL，不仅查询了商品报价，还从数据库中读取了本不应该看到的商品销售记录。这些都是播放器或网页本不应该提供的`越界行为`。

对漏洞领域的研究，主要涉及漏洞分析、漏洞利用和漏洞挖掘三个方面。

漏洞利用才是实施有效攻击的最核心技术，这一点，笔者也十分认同，而完成漏洞利用的前提，就是对漏洞原理的分析。漏洞分析，从本质上来说，就是要确定`漏洞产生的根本原因（没有判断字符串的输入长度）`、`触发漏洞的输入变量（字符串）`和`漏洞造成的最直接影响（比如最多溢出栈内存的多少个字节）`三点。

触发漏洞的输入变量，即POC。最常见的方式就是`根据公开的POC代码，分析软件逻辑，找到漏洞产生的根本原因，预估漏洞可以造成什么影响`。还有一种情况就是没有人公开POC，但程序已经打过补丁，此时就要分析者通过`补丁对比`，根据程序补丁前后的不同点，分析软件逻辑，找到漏洞点，逆推得到POC代码，然后再预估漏洞造成的影响。可以看出，`补丁对比`需要从一穷二白开始找到对漏洞分析的三点，不仅需要分析者熟知漏洞分析技巧，还要具备很强的逆向功底，因此，这也是漏洞分析领域技术含量最高的硬骨头。

产生漏洞最直观的解释就是，特殊的输入变量导致软件执行了特殊的程序逻辑。对漏洞的挖掘也因此分为了两类：学术界热衷于使用`静态分析`找到特殊的程序逻辑，工程界普遍采用`fuzzing`构造特殊的输入变量，目前结合两者，又出现了`符号执行`，利用符号模拟输入变量，执行不同的程序路径，进而一个程序路径对应一个方程，要想知道特定程序分支的输入变量，求解方程即可。

## 0x02_二进制漏洞攻防的进化史

二进制文件存储在硬盘中，系统会将其加载至虚拟内存中来运行它，内存中的二进制文件称之为进程。二进制文件在硬盘中，静态数据和指令都存放在同一个PE文件中，而映射为进程后，在内存中会被存放在`代码区`、`数据区`，而根据运行进程的需要，又开辟出用于函数调用和存放临时变量的`栈区`和动态存放数据、对象的`堆区`。

现代计算机都遵循冯诺依曼结构，而冯诺依曼结构的精髓在于：

> 处理器按照顺序执行指令和操作数据，而无论指令还是数据，它们的本质并没有区别，都是一串二进制数字的序列。

正因为用户输入的数据和开发者编写的指令在执行过程中全部被映射到一块4GB的虚拟内存当中，如果某些指令存在漏洞，将用户输入的某些数据，不小心覆盖掉了某些指令或其它数据所在的内存区域，而当被覆盖内存位置的数据或指令被执行或使用时，用户就有可能改变进程的原有逻辑，这样就造成了漏洞利用。

缓冲区溢出是最常见的二进制漏洞，其原理是：
> 在大缓冲区的数据向小缓冲区复制的过程中，由于没有注意小缓冲区的边界，`撑爆`较小的缓冲区，从而冲掉了和小缓冲区相邻内存的其它数据而引起的内存问题.

缓冲区可以是栈区、堆区和存放静态变量的数据区，从而会造成栈溢出、堆溢出等等。

### 栈溢出
栈区主要用于存放函数调用的参数和函数内部int、char数组等临时变量，下面是个标准的栈溢出模型：
```C
# include "stdafx.h"
# include <string.h>
void fun_a(char*src){
 int size_t = 20;
	char dst[20];
	memcpy(dst, src, size_t);
 if(size_t > 20)
  printf("bad");
}
void main(int argc, char*argv[]){
	if(argc <= 2)
		return;
	fun_a(argv[1]);
 printf("over");
}
```
调用Fun_a函数产生的栈区如下所示：
```bash
esp
 dst[20]  - 20bytes
 size_t   - 4bytes
 retn_eip - printf("over")指令的内存地址
 src      - 用户输入字符串的指针
ebp
```
当用户输入src超出规定的20字节时，将会覆盖掉size_t局部变量、retn_eip指令地址等，也就是说，用户具备了对这些栈内数据的修改权，因此恶意用户就能控制程序流程，将栈内size_t修改为大于20字节，使其输出正常情况下不会显示的bad，改变程序运行流程；还能够覆盖掉retn_eip指令地址指向kernel32中jmp esp指令的地址，将栈区存放src指针及之后的空间全部覆盖为shellcode，当fun_a函数返回时，转去执行这些代码，而不是返回至main函数。

经典的`jmp esp利用`：
```bash
esp
 dst[20]  - 20bytes
 ******   - 4bytes
 0x708657 - jmp esp指令的内存地址
 ***      - shellcode
 ***      - ...
ebp
```
当函数返回时，EIP指向0x708657，即准备执行jmp esp这条指令，而此时栈区的分布：
```bash
esp
 ***      - shellcode
 ***      - ...
ebp
```
程序会跳转至ESP执行写入的shellcode，这就是经典的jmp esp利用。
